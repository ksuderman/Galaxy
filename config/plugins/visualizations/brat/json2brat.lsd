#!/usr/bin/env lsd

if (args.size() == 0) {
    error "No file name provided."
    return
}

// The object we will be outputting.
brat = new Brat()
logger = new Logger()

// Flag used to prevent Markable annotations from being included
// multiple times.
includeMarkables = true

file = new File(args[0])

Data data = Serializer.parse(file.text)
//if (data.discriminator != Uri.LIF && data.discriminator != Uri.LAPPS) {
//    error "Invalid discriminator type. ${data.discriminator}"
//    return
//}

container = new Container((Map) data.payload)
brat.text = container.text

//addEntities(Uri.POS) { a -> [a.id, a.features.pos, [[a.start, a.end]]] }
addTokens()
addEntities(Uri.NE) { a -> [a.id, a.features.category, [[a.start, a.end]]] }
addRelation(Uri.DEPENDENCY) { a -> [a.id, a.label, [["Governor", a.features.governor], ["Dependent", a.features.dependent]]] }
addCoref()
addGenericRelations()

logger.log "writing output"
println Serializer.toPrettyJson(brat)
logger.log "Done"
logger.close()


void error(String message) {
    logger.log("Error: $message")
    brat.text = "Error: $message"
    logger.close()
    println Serializer.toPrettyJson(brat)
}

void addRelation(String type, Closure factory) {
    logger.log('Adding relations' + type)
    int count = 0
    find(type).each { a ->
        ++count
        brat.relations.add(factory(a))
    }
    logger.log("relations: $count")
}

void addEntities(String type, Closure factory) {
    logger.log("Adding entities $type")
    int count = 0
    find(type).each { a ->
        ++count
        brat.entities.add(factory(a))
    }
    logger.log("entities: $count")
}

void addTokens() {
    logger.log "Adding tokens+pos"
    //List<View> views = container.findViewsThatContain(Uri.POS)
    //if (views.size() == 0) {
    //    logger.log "No POS annotations found."
    //    return
    //}
    View view = container.views[-1]
    if (!view.contains(Uri.POS)) {
        logger.log "No POS annotations found."
        return
    }
    int count = 0
    view.annotations.findAll { it.atType == Uri.TOKEN }.each { a ->
        ++count
        brat.entities << [a.id, a.features.pos, [[a.start, a.end]]]
    }
    logger.log "Tokens: $count"
}

void addGenericRelations() {
    logger.log("Adding generic relations")
    int relations = 0
    int markables = 0
    find(Uri.GENERIC_RELATION).each { a ->
        ++relations
        brat.relations << [ a.id, a.label, [['Arg0', a.features.arguments[0]],['Arg1', a.features.arguments[1]]]]

    }
    if (includeMarkables) {
        find(Uri.MARKABLE).each { a ->
            ++markables
            brat.entities << [a.id, 'Markable', [[a.start, a.end]]]
        }
        includeMarkables = false
    }
    logger.log "relations: $relations"
    logger.log "markables: $markables"
}

List<Annotation> find(String type) {
    // `subtype` is a hack-around for services that don't return
    // the full URI.
    int index = type.lastIndexOf('/')
    String subtype = null
    if (index > 0) {
        subtype = type.substring(index + 1)
    }
    // Assume any annotations we are interested in are contained
    // in the last view.
    View last = container.views[-1]
    if (!last.contains(type) && !last.contains(subtype)) {
        return []
    }

    List<Annotation> annotations = last.findByAtType(type)
    if (annotations.size() == 0) {
        annotations = last.findByAtType(subtype)
    }
    return annotations
}

void addCoref() {
    logger.log "Adding coref"
    int coref = 0
    int markables = 0
    find(Uri.COREF).each { a ->
        // TODO I believe this is not correct as I believe the LAPPS coreference services
        // return a list of 'mentions'.
        ++coref
        brat.equivs << [ '*', 'Coreference', a.features.mentions[0], a.features.mentions[1]]
    }
    if (includeMarkables) {
        find(Uri.MARKABLE).each { a ->
            ++markables
            brat.entities << [a.id, 'Mention', [[a.start, a.end]]]
        }
        includeMarkables = false
    }
    logger.log "coref: $coref"
    logger.log "markables: $markables"
}

class Brat {
    String text
    List equivs = []
    List entities = []
    List relations = []
}

class Logger {
    List<String> lines = []

    void log(String line) {
        lines << line
    }

    void leftShift(String line) {
        log(line)
    }

    void close() {
        File logfile = new File('/tmp/json2brat.log')
        logfile.withWriter { writer ->
            lines.each { writer.writeLine(it) }
        }
    }
}
