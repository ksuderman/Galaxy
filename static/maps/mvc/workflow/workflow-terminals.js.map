{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["Toastr","window","workflow_globals","CollectionTypeDescription","collectionType","isCollection","rank","split","length","NULL_COLLECTION_TYPE_DESCRIPTION","canMatch","canMapOver","toString","append","otherCollectionType","equal","other","ANY_COLLECTION_TYPE_DESCRIPTION","$","extend","prototype","otherCollectionTypeDescription","requiredSuffix","_endsWith","effectiveMapOver","effectiveCollectionType","substring","str","suffix","indexOf","TerminalMapping","Backbone","Model","initialize","attr","mapOver","terminal","terminalMapping","disableMapOver","setMapOver","collectionTypeDescription","trigger","Terminal","element","connectors","connect","connector","push","node","markChanged","disconnect","splice","inArray","resetMappingIfNeeded","redraw","each","_","c","destroy","slice","destroyInvalidConnections","destroyIfInvalid","val","multiple","output_terminals","outputTerminal","isMappedOver","resetMapping","OutputTerminal","call","datatypes","hasConnectedOutputTerminals","hasConnectedMappedInputTerminals","mappedInputTerminals","mappedInput","noMappedInputs","hasMappedOverInputTerminals","connectedInput","handle2","BaseInputTerminal","update","input","canAccept","_inputFilled","attachable","reset","connected","inputFilled","_collectionAttached","firstOutput","handle1","_mappingConstraints","constraints","connectedMappedInputTerminals","inputTerminal","first","values","_producesAcceptableDatatype","t","thisDatatype","cat_outputs","concat","post_job_actions","pja_i","pja","action_type","output_name","name","action_arguments","newtype","other_datatype_i","other_datatype","app","isSubType","console","log","_otherCollectionType","otherMapOver","InputTerminal","extensions","collection","other_output","thisMapOver","mappingConstraints","every","bind","InputCollectionTerminal","collectionTypes","collection_types","_effectiveMapOver","some","collectionTypeIndex","_effectiveCollectionTypes","map","effectiveCollectionTypes","OutputCollectionTerminal","collection_type","collectionTypeSource","collection_type_source","output","newCollectionType","warning"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["// TODO; tie into Galaxy state?\nwindow.workflow_globals = window.workflow_globals || {};\nimport * as Toastr from \"libs/toastr\";\n\nfunction CollectionTypeDescription(collectionType) {\n    this.collectionType = collectionType;\n    this.isCollection = true;\n    this.rank = collectionType.split(\":\").length;\n}\n\nvar NULL_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: false,\n    canMatch: function() {\n        return false;\n    },\n    canMapOver: function() {\n        return false;\n    },\n    toString: function() {\n        return \"NullCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        return otherCollectionType;\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\nvar ANY_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: true,\n    canMatch: function(other) {\n        return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n    },\n    canMapOver: function() {\n        return false;\n    },\n    toString: function() {\n        return \"AnyCollectionType[]\";\n    },\n    append: function() {\n        return ANY_COLLECTION_TYPE_DESCRIPTION;\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\n$.extend(CollectionTypeDescription.prototype, {\n    append: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return this;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return otherCollectionTypeDescription;\n        }\n        return new CollectionTypeDescription(`${this.collectionType}:${otherCollectionTypeDescription.collectionType}`);\n    },\n    canMatch: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return true;\n        }\n        return otherCollectionTypeDescription.collectionType == this.collectionType;\n    },\n    canMapOver: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (this.rank <= otherCollectionTypeDescription.rank) {\n            // Cannot map over self...\n            return false;\n        }\n        var requiredSuffix = otherCollectionTypeDescription.collectionType;\n        return this._endsWith(this.collectionType, requiredSuffix);\n    },\n    effectiveMapOver: function(otherCollectionTypeDescription) {\n        var otherCollectionType = otherCollectionTypeDescription.collectionType;\n        var effectiveCollectionType = this.collectionType.substring(\n            0,\n            this.collectionType.length - otherCollectionType.length - 1\n        );\n        return new CollectionTypeDescription(effectiveCollectionType);\n    },\n    equal: function(otherCollectionTypeDescription) {\n        return otherCollectionTypeDescription.collectionType == this.collectionType;\n    },\n    toString: function() {\n        return `CollectionType[${this.collectionType}]`;\n    },\n    _endsWith: function(str, suffix) {\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n});\n\nvar TerminalMapping = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n        this.terminal = attr.terminal;\n        this.terminal.terminalMapping = this;\n    },\n    disableMapOver: function() {\n        this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n    },\n    setMapOver: function(collectionTypeDescription) {\n        // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n        // event?\n        this.mapOver = collectionTypeDescription;\n        this.trigger(\"change\");\n    }\n});\n\nvar Terminal = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.element = attr.element;\n        this.connectors = [];\n    },\n    connect: function(connector) {\n        this.connectors.push(connector);\n        if (this.node) {\n            this.node.markChanged();\n        }\n    },\n    disconnect: function(connector) {\n        this.connectors.splice($.inArray(connector, this.connectors), 1);\n        if (this.node) {\n            this.node.markChanged();\n            this.resetMappingIfNeeded();\n        }\n    },\n    redraw: function() {\n        $.each(this.connectors, (_, c) => {\n            c.redraw();\n        });\n    },\n    destroy: function() {\n        $.each(this.connectors.slice(), (_, c) => {\n            c.destroy();\n        });\n    },\n    destroyInvalidConnections: function() {\n        _.each(this.connectors, connector => {\n            if (connector) {\n                connector.destroyIfInvalid();\n            }\n        });\n    },\n    setMapOver: function(val) {\n        if (this.multiple) {\n            return; // Cannot set this to be multirun...\n        }\n\n        if (!this.mapOver().equal(val)) {\n            this.terminalMapping.setMapOver(val);\n            _.each(this.node.output_terminals, outputTerminal => {\n                outputTerminal.setMapOver(val);\n            });\n        }\n    },\n    mapOver: function() {\n        if (!this.terminalMapping) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        } else {\n            return this.terminalMapping.mapOver;\n        }\n    },\n    isMappedOver: function() {\n        return this.terminalMapping && this.terminalMapping.mapOver.isCollection;\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n    },\n\n    resetMappingIfNeeded: function() {} // Subclasses should override this...\n});\n\nvar OutputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n    },\n\n    resetMappingIfNeeded: function() {\n        // If inputs were only mapped over to preserve\n        // an output just disconnected reset these...\n        if (!this.node.hasConnectedOutputTerminals() && !this.node.hasConnectedMappedInputTerminals()) {\n            _.each(this.node.mappedInputTerminals(), mappedInput => {\n                mappedInput.resetMappingIfNeeded();\n            });\n        }\n\n        var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n        if (noMappedInputs) {\n            this.resetMapping();\n        }\n    },\n\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        _.each(this.connectors, connector => {\n            var connectedInput = connector.handle2;\n            if (connectedInput) {\n                // Not exactly right because this is still connected.\n                // Either rewrite resetMappingIfNeeded or disconnect\n                // and reconnect if valid.\n                connectedInput.resetMappingIfNeeded();\n                connector.destroyIfInvalid();\n            }\n        });\n    }\n});\n\nvar BaseInputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.update(attr.input); // subclasses should implement this...\n    },\n    canAccept: function(other) {\n        if (this._inputFilled()) {\n            return false;\n        } else {\n            return this.attachable(other);\n        }\n    },\n    resetMappingIfNeeded: function() {\n        var mapOver = this.mapOver();\n        if (!mapOver.isCollection) {\n            return;\n        }\n        // No output terminals are counting on this being mapped\n        // over if connected inputs are still mapped over or if none\n        // of the outputs are connected...\n        var reset = this.node.hasConnectedMappedInputTerminals() || !this.node.hasConnectedOutputTerminals();\n        if (reset) {\n            this.resetMapping();\n        }\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        if (!this.node.hasMappedOverInputTerminals()) {\n            _.each(this.node.output_terminals, terminal => {\n                // This shouldn't be called if there are mapped over\n                // outputs.\n                terminal.resetMapping();\n            });\n        }\n    },\n    connected: function() {\n        return this.connectors.length !== 0;\n    },\n    _inputFilled: function() {\n        var inputFilled;\n        if (!this.connected()) {\n            inputFilled = false;\n        } else {\n            if (this.multiple) {\n                if (this._collectionAttached()) {\n                    // Can only attach one collection to multiple input\n                    // data parameter.\n                    inputFilled = true;\n                } else {\n                    inputFilled = false;\n                }\n            } else {\n                inputFilled = true;\n            }\n        }\n        return inputFilled;\n    },\n    _collectionAttached: function() {\n        if (!this.connected()) {\n            return false;\n        } else {\n            var firstOutput = this.connectors[0].handle1;\n            if (!firstOutput) {\n                return false;\n            } else {\n                if (\n                    firstOutput.isCollection ||\n                    firstOutput.isMappedOver() ||\n                    firstOutput.datatypes.indexOf(\"input_collection\") > 0\n                ) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n    },\n    _mappingConstraints: function() {\n        // If this is a connected terminal, return list of collection types\n        // other terminals connected to node are constraining mapping to.\n        if (!this.node) {\n            return []; // No node - completely unconstrained\n        }\n        var mapOver = this.mapOver();\n        if (mapOver.isCollection) {\n            return [mapOver];\n        }\n\n        var constraints = [];\n        if (!this.node.hasConnectedOutputTerminals()) {\n            _.each(this.node.connectedMappedInputTerminals(), inputTerminal => {\n                constraints.push(inputTerminal.mapOver());\n            });\n        } else {\n            // All outputs should have same mapOver status - least specific.\n            constraints.push(_.first(_.values(this.node.output_terminals)).mapOver());\n        }\n        return constraints;\n    },\n    _producesAcceptableDatatype: function(other) {\n        // other is a non-collection output...\n        for (var t in this.datatypes) {\n            var thisDatatype = this.datatypes[t];\n            if (thisDatatype == \"input\") {\n                return true;\n            }\n            var cat_outputs = [];\n            cat_outputs = cat_outputs.concat(other.datatypes);\n            if (other.node.post_job_actions) {\n                for (var pja_i in other.node.post_job_actions) {\n                    var pja = other.node.post_job_actions[pja_i];\n                    if (\n                        pja.action_type == \"ChangeDatatypeAction\" &&\n                        (pja.output_name === \"\" || pja.output_name == other.name) &&\n                        pja.action_arguments\n                    ) {\n                        cat_outputs.push(pja.action_arguments.newtype);\n                    }\n                }\n            }\n            // FIXME: No idea what to do about case when datatype is 'input'\n            for (var other_datatype_i in cat_outputs) {\n                var other_datatype = cat_outputs[other_datatype_i];\n                if (\n                    other_datatype == \"input\" ||\n                    other_datatype == \"_sniff_\" ||\n                    other_datatype == \"input_collection\" ||\n                    window.workflow_globals.app.isSubType(cat_outputs[other_datatype_i], thisDatatype)\n                ) {\n                    return true;\n                }\n                if ( thisDatatype === 'gate' || thisDatatype === 'lif' ) {\n                    return other_datatype === 'lif' || other_datatype === 'gate'\n                }\n            }\n        }\n        console.log(\"No acceptable datatype found.\")\n        return false;\n    },\n    _otherCollectionType: function(other) {\n        var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n        if (other.isCollection) {\n            otherCollectionType = other.collectionType;\n        }\n        var otherMapOver = other.mapOver();\n        if (otherMapOver.isCollection) {\n            otherCollectionType = otherMapOver.append(otherCollectionType);\n        }\n        return otherCollectionType;\n    }\n});\n\nvar InputTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.datatypes = input.extensions;\n        this.multiple = input.multiple;\n        this.collection = false;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other_output = connector.handle1;\n        if (!other_output) {\n            return;\n        }\n        var otherCollectionType = this._otherCollectionType(other_output);\n        if (otherCollectionType.isCollection) {\n            this.setMapOver(otherCollectionType);\n        }\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        var thisMapOver = this.mapOver();\n        if (otherCollectionType.isCollection) {\n            if (this.multiple) {\n                if (this.connected() && !this._collectionAttached()) {\n                    // if single inputs attached, cannot also attach a\n                    // collection (yet...)\n                    return false;\n                }\n                if (otherCollectionType.rank == 1) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    // TODO: Allow subcollection mapping over this as if it were\n                    // a list collection input.\n                    return false;\n                }\n            }\n            if (thisMapOver.isCollection && thisMapOver.canMatch(otherCollectionType)) {\n                return this._producesAcceptableDatatype(other);\n            } else {\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(_.bind(otherCollectionType.canMatch, otherCollectionType))) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    return false;\n                }\n            }\n        } else if (thisMapOver.isCollection) {\n            // Attempting to match a non-collection output to an\n            // explicitly collection input.\n            return false;\n        }\n        return this._producesAcceptableDatatype(other);\n    }\n});\n\nvar InputCollectionTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.multiple = false;\n        this.collection = true;\n        this.datatypes = input.extensions;\n        var collectionTypes = [];\n        if (input.collection_types) {\n            _.each(input.collection_types, collectionType => {\n                collectionTypes.push(new CollectionTypeDescription(collectionType));\n            });\n        } else {\n            collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n        }\n        this.collectionTypes = collectionTypes;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other = connector.handle1;\n        if (!other) {\n            return;\n        }\n\n        var effectiveMapOver = this._effectiveMapOver(other);\n        this.setMapOver(effectiveMapOver);\n    },\n    _effectiveMapOver: function(other) {\n        var collectionTypes = this.collectionTypes;\n        var otherCollectionType = this._otherCollectionType(other);\n        var canMatch = _.some(collectionTypes, collectionType => collectionType.canMatch(otherCollectionType));\n\n        if (!canMatch) {\n            for (var collectionTypeIndex in collectionTypes) {\n                var collectionType = collectionTypes[collectionTypeIndex];\n                if (otherCollectionType.canMapOver(collectionType)) {\n                    var effectiveMapOver = otherCollectionType.effectiveMapOver(collectionType);\n                    if (effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION) {\n                        return effectiveMapOver;\n                    }\n                }\n            }\n        }\n        return NULL_COLLECTION_TYPE_DESCRIPTION;\n    },\n    _effectiveCollectionTypes: function() {\n        var thisMapOver = this.mapOver();\n        return _.map(this.collectionTypes, t => thisMapOver.append(t));\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        if (otherCollectionType.isCollection) {\n            var effectiveCollectionTypes = this._effectiveCollectionTypes();\n            var thisMapOver = this.mapOver();\n            var canMatch = _.some(effectiveCollectionTypes, effectiveCollectionType =>\n                effectiveCollectionType.canMatch(otherCollectionType)\n            );\n            if (canMatch) {\n                // Only way a direct match...\n                return this._producesAcceptableDatatype(other);\n                // Otherwise we need to mapOver\n            } else if (thisMapOver.isCollection) {\n                // In this case, mapOver already set and we didn't match skipping...\n                return false;\n            } else if (_.some(this.collectionTypes, collectionType => otherCollectionType.canMapOver(collectionType))) {\n                var effectiveMapOver = this._effectiveMapOver(other);\n                if (!effectiveMapOver.isCollection) {\n                    return false;\n                }\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                    return this._producesAcceptableDatatype(other);\n                }\n            }\n        }\n        return false;\n    }\n});\n\nvar OutputCollectionTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n        if (attr.collection_type) {\n            this.collectionType = new CollectionTypeDescription(attr.collection_type);\n        } else {\n            var collectionTypeSource = attr.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\"Warning: No collection type or collection type source defined.\");\n            }\n            this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n        this.isCollection = true;\n    },\n    update: function(output) {\n        var newCollectionType;\n        if (output.collection_type) {\n            newCollectionType = new CollectionTypeDescription(output.collection_type);\n        } else {\n            var collectionTypeSource = output.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\"Warning: No collection type or collection type source defined.\");\n            }\n            newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n\n        if (newCollectionType.collectionType != this.collectionType.collectionType) {\n            _.each(this.connectors, connector => {\n                // TODO: consider checking if connection valid before removing...\n                Toastr.warning(\"Destroying a connection because collection type has changed.\");\n                connector.destroy();\n            });\n        }\n        this.collectionType = newCollectionType;\n    }\n});\n\nexport default {\n    InputTerminal: InputTerminal,\n    OutputTerminal: OutputTerminal,\n    InputCollectionTerminal: InputCollectionTerminal,\n    OutputCollectionTerminal: OutputCollectionTerminal,\n    TerminalMapping: TerminalMapping,\n\n    // test export\n    CollectionTypeDescription: CollectionTypeDescription,\n    NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n    ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n};\n"]}