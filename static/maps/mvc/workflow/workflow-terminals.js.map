{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["CollectionTypeDescription","collectionType","this","isCollection","Toastr","split","length","window","workflow_globals","NULL_COLLECTION_TYPE_DESCRIPTION","canMatch","canMapOver","toString","append","otherCollectionType","equal","other","ANY_COLLECTION_TYPE_DESCRIPTION","$","extend","otherCollectionTypeDescription","rank","requiredSuffix","effectiveMapOver","substring","_endsWith","str","suffix","indexOf","TerminalMapping","initialize","attr","mapOver","terminal","disableMapOver","setMapOver","effectiveCollectionType","collectionTypeDescription","trigger","Terminal","Backbone","Model","element","connectors","connect","connector","disconnect","splice","inArray","node","markChanged","redraw","each","_","c","destroy","slice","multiple","val","terminalMapping","outputTerminal","destroyInvalidConnections","resetMapping","resetMappingIfNeeded","OutputTerminal","datatypes","hasConnectedOutputTerminals","hasConnectedMappedInputTerminals","mappedInput","hasMappedOverInputTerminals","destroyIfInvalid","BaseInputTerminal","noMappedInputs","call","update","canAccept","_inputFilled","connectedInput","input","output_terminals","connected","reset","_collectionAttached","handle1","inputFilled","firstOutput","_mappingConstraints","constraints","push","first","values","connectedMappedInputTerminals","inputTerminal","_producesAcceptableDatatype","t","cat_outputs","concat","pja_i","pja","action_type","output_name","name","action_arguments","newtype","thisDatatype","other_datatype_i","other_datatype","post_job_actions","isSubType","console","log","_otherCollectionType","otherMapOver","prototype","other_output","extensions","collection","thisMapOver","every","bind","InputCollectionTerminal","collectionTypes","collection_types","_effectiveMapOver","some","collectionTypeIndex","_effectiveCollectionTypes","map","attachable","effectiveCollectionTypes","OutputCollectionTerminal","collection_type","mappingConstraints","output","collection_type_source","newCollectionType","collectionTypeSource","warning","InputTerminal"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["// TODO; tie into Galaxy state?\nwindow.workflow_globals = window.workflow_globals || {};\nimport * as Toastr from \"libs/toastr\";\n\nfunction CollectionTypeDescription(collectionType) {\n    this.collectionType = collectionType;\n    this.isCollection = true;\n    this.rank = collectionType.split(\":\").length;\n}\n\nvar NULL_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: false,\n    canMatch: function() {\n        return false;\n    },\n    canMapOver: function() {\n        return false;\n    },\n    toString: function() {\n        return \"NullCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        return otherCollectionType;\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\nvar ANY_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: true,\n    canMatch: function(other) {\n        return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n    },\n    canMapOver: function() {\n        return false;\n    },\n    toString: function() {\n        return \"AnyCollectionType[]\";\n    },\n    append: function() {\n        return ANY_COLLECTION_TYPE_DESCRIPTION;\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\n$.extend(CollectionTypeDescription.prototype, {\n    append: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return this;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return otherCollectionTypeDescription;\n        }\n        return new CollectionTypeDescription(`${this.collectionType}:${otherCollectionTypeDescription.collectionType}`);\n    },\n    canMatch: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return true;\n        }\n        return otherCollectionTypeDescription.collectionType == this.collectionType;\n    },\n    canMapOver: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (this.rank <= otherCollectionTypeDescription.rank) {\n            // Cannot map over self...\n            return false;\n        }\n        var requiredSuffix = otherCollectionTypeDescription.collectionType;\n        return this._endsWith(this.collectionType, requiredSuffix);\n    },\n    effectiveMapOver: function(otherCollectionTypeDescription) {\n        var otherCollectionType = otherCollectionTypeDescription.collectionType;\n        var effectiveCollectionType = this.collectionType.substring(\n            0,\n            this.collectionType.length - otherCollectionType.length - 1\n        );\n        return new CollectionTypeDescription(effectiveCollectionType);\n    },\n    equal: function(otherCollectionTypeDescription) {\n        return otherCollectionTypeDescription.collectionType == this.collectionType;\n    },\n    toString: function() {\n        return `CollectionType[${this.collectionType}]`;\n    },\n    _endsWith: function(str, suffix) {\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n});\n\nvar TerminalMapping = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n        this.terminal = attr.terminal;\n        this.terminal.terminalMapping = this;\n    },\n    disableMapOver: function() {\n        this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n    },\n    setMapOver: function(collectionTypeDescription) {\n        // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n        // event?\n        this.mapOver = collectionTypeDescription;\n        this.trigger(\"change\");\n    }\n});\n\nvar Terminal = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.element = attr.element;\n        this.connectors = [];\n    },\n    connect: function(connector) {\n        this.connectors.push(connector);\n        if (this.node) {\n            this.node.markChanged();\n        }\n    },\n    disconnect: function(connector) {\n        this.connectors.splice($.inArray(connector, this.connectors), 1);\n        if (this.node) {\n            this.node.markChanged();\n            this.resetMappingIfNeeded();\n        }\n    },\n    redraw: function() {\n        $.each(this.connectors, (_, c) => {\n            c.redraw();\n        });\n    },\n    destroy: function() {\n        $.each(this.connectors.slice(), (_, c) => {\n            c.destroy();\n        });\n    },\n    destroyInvalidConnections: function() {\n        _.each(this.connectors, connector => {\n            if (connector) {\n                connector.destroyIfInvalid();\n            }\n        });\n    },\n    setMapOver: function(val) {\n        if (this.multiple) {\n            return; // Cannot set this to be multirun...\n        }\n\n        if (!this.mapOver().equal(val)) {\n            this.terminalMapping.setMapOver(val);\n            _.each(this.node.output_terminals, outputTerminal => {\n                outputTerminal.setMapOver(val);\n            });\n        }\n    },\n    mapOver: function() {\n        if (!this.terminalMapping) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        } else {\n            return this.terminalMapping.mapOver;\n        }\n    },\n    isMappedOver: function() {\n        return this.terminalMapping && this.terminalMapping.mapOver.isCollection;\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n    },\n\n    resetMappingIfNeeded: function() {} // Subclasses should override this...\n});\n\nvar OutputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n    },\n\n    resetMappingIfNeeded: function() {\n        // If inputs were only mapped over to preserve\n        // an output just disconnected reset these...\n        if (!this.node.hasConnectedOutputTerminals() && !this.node.hasConnectedMappedInputTerminals()) {\n            _.each(this.node.mappedInputTerminals(), mappedInput => {\n                mappedInput.resetMappingIfNeeded();\n            });\n        }\n\n        var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n        if (noMappedInputs) {\n            this.resetMapping();\n        }\n    },\n\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        _.each(this.connectors, connector => {\n            var connectedInput = connector.handle2;\n            if (connectedInput) {\n                // Not exactly right because this is still connected.\n                // Either rewrite resetMappingIfNeeded or disconnect\n                // and reconnect if valid.\n                connectedInput.resetMappingIfNeeded();\n                connector.destroyIfInvalid();\n            }\n        });\n    }\n});\n\nvar BaseInputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.update(attr.input); // subclasses should implement this...\n    },\n    canAccept: function(other) {\n        if (this._inputFilled()) {\n            return false;\n        } else {\n            return this.attachable(other);\n        }\n    },\n    resetMappingIfNeeded: function() {\n        var mapOver = this.mapOver();\n        if (!mapOver.isCollection) {\n            return;\n        }\n        // No output terminals are counting on this being mapped\n        // over if connected inputs are still mapped over or if none\n        // of the outputs are connected...\n        var reset = this.node.hasConnectedMappedInputTerminals() || !this.node.hasConnectedOutputTerminals();\n        if (reset) {\n            this.resetMapping();\n        }\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        if (!this.node.hasMappedOverInputTerminals()) {\n            _.each(this.node.output_terminals, terminal => {\n                // This shouldn't be called if there are mapped over\n                // outputs.\n                terminal.resetMapping();\n            });\n        }\n    },\n    connected: function() {\n        return this.connectors.length !== 0;\n    },\n    _inputFilled: function() {\n        var inputFilled;\n        if (!this.connected()) {\n            inputFilled = false;\n        } else {\n            if (this.multiple) {\n                if (this._collectionAttached()) {\n                    // Can only attach one collection to multiple input\n                    // data parameter.\n                    inputFilled = true;\n                } else {\n                    inputFilled = false;\n                }\n            } else {\n                inputFilled = true;\n            }\n        }\n        return inputFilled;\n    },\n    _collectionAttached: function() {\n        if (!this.connected()) {\n            return false;\n        } else {\n            var firstOutput = this.connectors[0].handle1;\n            if (!firstOutput) {\n                return false;\n            } else {\n                if (\n                    firstOutput.isCollection ||\n                    firstOutput.isMappedOver() ||\n                    firstOutput.datatypes.indexOf(\"input_collection\") > 0\n                ) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n    },\n    _mappingConstraints: function() {\n        // If this is a connected terminal, return list of collection types\n        // other terminals connected to node are constraining mapping to.\n        if (!this.node) {\n            return []; // No node - completely unconstrained\n        }\n        var mapOver = this.mapOver();\n        if (mapOver.isCollection) {\n            return [mapOver];\n        }\n\n        var constraints = [];\n        if (!this.node.hasConnectedOutputTerminals()) {\n            _.each(this.node.connectedMappedInputTerminals(), inputTerminal => {\n                constraints.push(inputTerminal.mapOver());\n            });\n        } else {\n            // All outputs should have same mapOver status - least specific.\n            constraints.push(_.first(_.values(this.node.output_terminals)).mapOver());\n        }\n        return constraints;\n    },\n    _producesAcceptableDatatype: function(other) {\n        // other is a non-collection output...\n        for (var t in this.datatypes) {\n            var thisDatatype = this.datatypes[t];\n            if (thisDatatype == \"input\") {\n                return true;\n            }\n            var cat_outputs = [];\n            cat_outputs = cat_outputs.concat(other.datatypes);\n            if (other.node.post_job_actions) {\n                for (var pja_i in other.node.post_job_actions) {\n                    var pja = other.node.post_job_actions[pja_i];\n                    if (\n                        pja.action_type == \"ChangeDatatypeAction\" &&\n                        (pja.output_name === \"\" || pja.output_name == other.name) &&\n                        pja.action_arguments\n                    ) {\n                        cat_outputs.push(pja.action_arguments.newtype);\n                    }\n                }\n            }\n            // FIXME: No idea what to do about case when datatype is 'input'\n            for (var other_datatype_i in cat_outputs) {\n                var other_datatype = cat_outputs[other_datatype_i];\n                if (\n                    other_datatype == \"input\" ||\n                    other_datatype == \"_sniff_\" ||\n                    other_datatype == \"input_collection\" ||\n                    window.workflow_globals.app.isSubType(cat_outputs[other_datatype_i], thisDatatype)\n                ) {\n                    return true;\n                }\n                if ( thisDatatype === 'gate' || thisDatatype === 'lif' ) {\n                    return other_datatype === 'lif' || other_datatype === 'gate'\n                }\n            }\n        }\n        console.log(\"No acceptable datatype found.\")\n        return false;\n    },\n    _otherCollectionType: function(other) {\n        var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n        if (other.isCollection) {\n            otherCollectionType = other.collectionType;\n        }\n        var otherMapOver = other.mapOver();\n        if (otherMapOver.isCollection) {\n            otherCollectionType = otherMapOver.append(otherCollectionType);\n        }\n        return otherCollectionType;\n    }\n});\n\nvar InputTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.datatypes = input.extensions;\n        this.multiple = input.multiple;\n        this.collection = false;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other_output = connector.handle1;\n        if (!other_output) {\n            return;\n        }\n        var otherCollectionType = this._otherCollectionType(other_output);\n        if (otherCollectionType.isCollection) {\n            this.setMapOver(otherCollectionType);\n        }\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        var thisMapOver = this.mapOver();\n        if (otherCollectionType.isCollection) {\n            if (this.multiple) {\n                if (this.connected() && !this._collectionAttached()) {\n                    // if single inputs attached, cannot also attach a\n                    // collection (yet...)\n                    return false;\n                }\n                if (otherCollectionType.rank == 1) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    // TODO: Allow subcollection mapping over this as if it were\n                    // a list collection input.\n                    return false;\n                }\n            }\n            if (thisMapOver.isCollection && thisMapOver.canMatch(otherCollectionType)) {\n                return this._producesAcceptableDatatype(other);\n            } else {\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(_.bind(otherCollectionType.canMatch, otherCollectionType))) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    return false;\n                }\n            }\n        } else if (thisMapOver.isCollection) {\n            // Attempting to match a non-collection output to an\n            // explicitly collection input.\n            return false;\n        }\n        return this._producesAcceptableDatatype(other);\n    }\n});\n\nvar InputCollectionTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.multiple = false;\n        this.collection = true;\n        this.datatypes = input.extensions;\n        var collectionTypes = [];\n        if (input.collection_types) {\n            _.each(input.collection_types, collectionType => {\n                collectionTypes.push(new CollectionTypeDescription(collectionType));\n            });\n        } else {\n            collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n        }\n        this.collectionTypes = collectionTypes;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other = connector.handle1;\n        if (!other) {\n            return;\n        }\n\n        var effectiveMapOver = this._effectiveMapOver(other);\n        this.setMapOver(effectiveMapOver);\n    },\n    _effectiveMapOver: function(other) {\n        var collectionTypes = this.collectionTypes;\n        var otherCollectionType = this._otherCollectionType(other);\n        var canMatch = _.some(collectionTypes, collectionType => collectionType.canMatch(otherCollectionType));\n\n        if (!canMatch) {\n            for (var collectionTypeIndex in collectionTypes) {\n                var collectionType = collectionTypes[collectionTypeIndex];\n                if (otherCollectionType.canMapOver(collectionType)) {\n                    var effectiveMapOver = otherCollectionType.effectiveMapOver(collectionType);\n                    if (effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION) {\n                        return effectiveMapOver;\n                    }\n                }\n            }\n        }\n        return NULL_COLLECTION_TYPE_DESCRIPTION;\n    },\n    _effectiveCollectionTypes: function() {\n        var thisMapOver = this.mapOver();\n        return _.map(this.collectionTypes, t => thisMapOver.append(t));\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        if (otherCollectionType.isCollection) {\n            var effectiveCollectionTypes = this._effectiveCollectionTypes();\n            var thisMapOver = this.mapOver();\n            var canMatch = _.some(effectiveCollectionTypes, effectiveCollectionType =>\n                effectiveCollectionType.canMatch(otherCollectionType)\n            );\n            if (canMatch) {\n                // Only way a direct match...\n                return this._producesAcceptableDatatype(other);\n                // Otherwise we need to mapOver\n            } else if (thisMapOver.isCollection) {\n                // In this case, mapOver already set and we didn't match skipping...\n                return false;\n            } else if (_.some(this.collectionTypes, collectionType => otherCollectionType.canMapOver(collectionType))) {\n                var effectiveMapOver = this._effectiveMapOver(other);\n                if (!effectiveMapOver.isCollection) {\n                    return false;\n                }\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                    return this._producesAcceptableDatatype(other);\n                }\n            }\n        }\n        return false;\n    }\n});\n\nvar OutputCollectionTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n        if (attr.collection_type) {\n            this.collectionType = new CollectionTypeDescription(attr.collection_type);\n        } else {\n            var collectionTypeSource = attr.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\"Warning: No collection type or collection type source defined.\");\n            }\n            this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n        this.isCollection = true;\n    },\n    update: function(output) {\n        var newCollectionType;\n        if (output.collection_type) {\n            newCollectionType = new CollectionTypeDescription(output.collection_type);\n        } else {\n            var collectionTypeSource = output.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\"Warning: No collection type or collection type source defined.\");\n            }\n            newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n\n        if (newCollectionType.collectionType != this.collectionType.collectionType) {\n            _.each(this.connectors, connector => {\n                // TODO: consider checking if connection valid before removing...\n                Toastr.warning(\"Destroying a connection because collection type has changed.\");\n                connector.destroy();\n            });\n        }\n        this.collectionType = newCollectionType;\n    }\n});\n\nexport default {\n    InputTerminal: InputTerminal,\n    OutputTerminal: OutputTerminal,\n    InputCollectionTerminal: InputCollectionTerminal,\n    OutputCollectionTerminal: OutputCollectionTerminal,\n    TerminalMapping: TerminalMapping,\n\n    // test export\n    CollectionTypeDescription: CollectionTypeDescription,\n    NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n    ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n};\n"]}